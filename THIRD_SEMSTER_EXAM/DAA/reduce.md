Below is the complete structured output you requested.
I am giving you **three separate deliverables**:

1. **EXACT syllabus-related questions extracted from all previous years**
2. **A predicted question bank strictly based on your new syllabus**
3. **A clean list of topics to avoid during revision (not in new syllabus)**

This is optimized so you can revise faster and smarter.

---

# **1) EXACT SYLLABUS-RELATED QUESTIONS (Filtered from All Papers)**

Below I’m including ONLY the questions that match your new syllabus modules:

---

## **MODULE–I (Asymptotic, Recurrence, Sorting, Divide & Conquer, Heap, Priority Queue)**

### **From Previous Papers**

* Is f(n) = 3n² + 5n + 6 = O(n³)?
* Worst-case analysis of merge sort input size scaling.
* Solve the recurrence:

  * T(n)=2T(n/2)+n³
  * T(n)=16T(n/4)+n
* Big-Oh & Big-Omega definitions; find Big-Oh of f(n)=4n²+2n+7.
* Explain Divide and Conquer; write recursive binary search algorithm.
* Sort using merge sort: 34, 67, 10, 33...
* Time complexity of shortest path (n vertices, e edges).
* Construct heap (max/min) using given numbers.
* Heap sort demonstration.
* Quick sort: sort list & analyze time complexity.
* Quick sort: best/worst/average case complexity.
* Solve recurrence T(n)=T(n/2)+c n².
* Construct heap using heapify.

### **Syllabus-Related (Heap, PQ)**

* Priority queue usage (implicitly tested in heap problems).

---

## **MODULE–II (Dynamic Programming + Greedy Algorithms)**

### **Dynamic Programming**

* Matrix chain multiplication: compute m[][], s[][]; minimum multiplications.
* Longest Common Subsequence for given sequences.
* Bottom-up DP for 0/1 Knapsack.
* DP elements (short questions).
* Relation between principle of optimality (appears indirectly in DP).
* MCM for chain of dimensions (several questions).

### **Greedy Algorithms**

* Difference between Greedy vs Dynamic Programming.
* Solve fractional knapsack using greedy.
* Prove fractional knapsack optimal.
* Huffman coding tree and decoding.
* Construct Huffman codes with given frequencies.
* Activity selection (NOT in syllabus formally, but borderline Greedy example).
* Shortest path using Dijkstra (belongs to greedy category in many courses).

---

## **MODULE–III (Disjoint Sets, Graph Algorithms, MST, Shortest Paths)**

### **Disjoint Sets**

* Define Disjoint Set and supported operations.
* Linked list vs tree representation (partial syllabus).
* Union-Find operations in general.

### **Graph Algorithms**

* BFS and DFS advantages (questions comparing DFS/BFS).
* BFS, DFS definitions and algorithms.
* Prim vs Kruskal; find maximum/min weight of MST.
* Construct MST using Prim/Kruskal.
* MST theory questions.
* Bellman-Ford algorithm: find shortest path & time complexity.
* Dijkstra algorithm application questions.
* Floyd-Warshall (not directly asked in these papers but in your syllabus).

---

## **MODULE–IV (Maximum Flow, FFT, String Matching, NP-Completeness, Approximation)**

### **Maximum Flow**

* Basic: Max-flow concepts are syllabus but previous questions asked max-cut relation (excluded).
* Some basic flow network questions from older papers.

### **String Matching**

* Rabin-Karp algorithm (multiple questions).
* Naive string matching special case acceleration.
* Pattern matching numerical example (Rabin-Karp hash calculations).

### **NP-Completeness**

* Determine P / NP / NP-Complete for SAT, Hamiltonian cycle, TSP, Knapsack, Clique, Set partitioning.
* Define polynomial-time reducibility.
* P, NP, NP-hard, NP-Complete relationship (multiple long answers).

### **Approximation Algorithms**

* Approximation algorithm discussion.
* Greedy approximation for Vertex cover / Set cover (although not asked explicitly, syllabus includes it).

---

# **2) PREDICTED QUESTION BANK (STRICTLY BASED ON YOUR NEW SYLLABUS)**

These are **high-probability exam questions** matching modules EXACTLY.

---

## **MODULE–I: Algorithm Analysis, Recurrences, Sorting, Heap**

1. Prove that f(n) = 3n² + 7n + 5 is O(n²).
2. Solve using Master’s method:

   * T(n) = 2T(n/2) + n log n
   * T(n) = 4T(n/2) + n²
3. Compare Divide & Conquer with Dynamic Programming.
4. Derive worst-case running time of Merge Sort.
5. Analyze worst, best, average case of Quick Sort.
6. Demonstrate Heap Sort for a given sequence of 10–12 numbers.
7. Build a max-heap from a given array and show each step.
8. Explain priority queue and its applications.
9. Compare asymptotic notations O, Ω, Θ with formal definitions.
10. Binary search: derive recurrence and solve using recursion tree.

---

## **MODULE–II: Dynamic Programming & Greedy**

### **Dynamic Programming**

1. Compute optimal parenthesization of 5 matrices using MCM.
2. Write DP algorithm for Longest Common Subsequence (LCS) and compute LCS for given sequences.
3. Solve 0/1 Knapsack bottom-up with DP table.
4. Discuss principle of optimality in context of DP.

### **Greedy**

5. Fractional Knapsack: prove greedy choice property.
6. Construct Huffman tree and compute code lengths.
7. Activity selection (only if instructor uses it; borderline).
8. Shortest path using Dijkstra (Greedy-based).

---

## **MODULE–III: Disjoint Sets, Graph Algorithms**

1. Explain disjoint set data structure:

   * Make-set, Union, Find
2. Implement union-find with path compression and union by rank.
3. BFS: compute BFS tree for a given graph.
4. DFS: compute DFS and identify discovery/finish times.
5. Construct MST using:

   * Kruskal
   * Prim
6. Show how Kruskal uses disjoint sets.
7. Compute shortest path using:

   * Bellman-Ford
   * Dijkstra
8. All-pair shortest path using Floyd-Warshall.

---

## **MODULE–IV: Max Flow, FFT, NP-Completeness, String Matching, Approximation**

### **Maximum Flow**

1. Explain Ford-Fulkerson with example flow network.
2. Find max flow in a small graph using Ford-Fulkerson or Edmonds-Karp.

### **FFT & Polynomial**

3. Represent polynomials using arrays; multiply using DFT/FFT.
4. Explain FFT butterfly diagram.

### **String Matching**

5. Write Rabin-Karp algorithm and compute match positions.
6. Compare Naive vs Rabin-Karp vs KMP (even though KMP not needed practically).

### **NP-Completeness**

7. Define P, NP, NP-Complete, NP-Hard with examples.
8. Show that Clique is NP-Complete (outline).
9. Polynomial-time verification examples.

### **Approximation Algorithms**

10. Approximation algorithm for:

    * Vertex cover
    * Set cover
    * TSP (metric)
    * Subset-sum

---

# **3) TOPICS TO AVOID DURING REVISION (NOT IN YOUR SYLLABUS)**

Clear list—**do NOT waste time on these**:

### **Sorting / Trees**

* Insertion sort
* Red-Black trees
* AVL trees
* Optimal Binary Search Tree (DP)

### **Backtracking & Branch & Bound**

* N-Queens
* Subset-sum backtracking
* State-space tree design
* Branch and Bound technique
* TSP via backtracking or B&B

### **Graph Theory Not Required**

* Graph coloring / 4-colorability
* Maximum cut
* Hamiltonian cycle reduction proofs (heavy theory)

### **String Matching Beyond Syllabus**

* KMP
* Finite automata pattern matching method

### **Misc Non-Syllabus Theory**

* Deterministic vs Non-Deterministic algorithms
* Activity selection (not officially in syllabus)
* Job sequencing with deadlines
* Monge arrays, matroids, other Greedy theory
* Exhaustive algorithm criteria / definitions
* Generic pseudocode complexity questions (nested loops etc.)

---

# **If you want, I can also prepare:**

### **1) A complete 30-day revision plan**

### **2) Chapter-wise expected 16-mark questions**

### **3) A fully solved notes PDF (all modules)**

Just tell me.
